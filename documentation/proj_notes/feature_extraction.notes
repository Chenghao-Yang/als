
Notes

  Abc_NtkToMap // perform mapping
  Abc_NtkFromMap // reconstruct the network after mapping


look at mapper.h or .c
look at abc.h or .c for the following "types"

In function Abc_NtkToMap (located at line 263 of abcMap.c)
  Map_Node_t * vNodes // seems to be a node pointer for map
                         lets look at the functionality here and how to call it
                         call constructor Map_NodeAnd(<lots of stuff>)


  type Vec_Ptr_t 
    vNodes // looks like a vector of nodes // to load the AIG into the mapper // 
    vNodes = Abc_AigDfsMap(pNtk)
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     struct Vec_Ptr_t_
     {
         int              nCap;
         int              nSize;
         void **          pArray;
     };

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  type Abc_Obj_t *
    pNode // look at the functionality here // is of type Abc_Obj_t*
    pFanin // same as above
    pPrev // maybe a previous node?

    Abc_ptr_t is defined in abc.h in /src/base/abc/abc.h
      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      struct Abc_Obj_t_     // 48/72 bytes (32-bits/64-bits)
      {
         Abc_Ntk_t *       pNtk;          // the host network
         Abc_Obj_t *       pNext;         // the next pointer in the hash table
         int               Id;            // the object ID
         unsigned          Type    :  4;  // the object type
         unsigned          fMarkA  :  1;  // the multipurpose mark
         unsigned          fMarkB  :  1;  // the multipurpose mark
         unsigned          fMarkC  :  1;  // the multipurpose mark
         unsigned          fPhase  :  1;  // the flag to mark the phase of equivalent node
         unsigned          fExor   :  1;  // marks AIG node that is a root of EXOR
         unsigned          fPersist:  1;  // marks the persistant AIG node
         unsigned          fCompl0 :  1;  // complemented attribute of the first fanin in the AIG
         unsigned          fCompl1 :  1;  // complemented attribute of the second fanin in theAIG
         unsigned          Level   : 20;  // the level of the node
         Vec_Int_t         vFanins;       // the array of fanins
         Vec_Int_t         vFanouts;      // the array of fanouts
         union { void *    pData;         // the network specific data
           int             iData; };      // (SOP, BDD, gate, equiv class, etc)
         union { void *    pTemp;         // temporary store for user's data
           Abc_Obj_t *     pCopy;         // the copy of this object
           int             iTemp;
           float           dTemp; };
     };

      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~



  also Abc_ObjFanout0(pNode) // look for functionality




  Abc_Ntk_t object (located in ~als/dnn/abc/src/base/abc/abc.h)
   struct Abc_Ntk_t_
  {
     // general information
     Abc_NtkType_t     ntkType;       // type of the network
     Abc_NtkFunc_t     ntkFunc;       // functionality of the network
     char *            pName;         // the network name
     char *            pSpec;         // the name of the spec file if present
     Nm_Man_t *        pManName;      // name manager (stores names of objects)
     // components of the network
     Vec_Ptr_t *       vObjs;         // the array of all objects (net, nodes, latches, etc)
     Vec_Ptr_t *       vPis;          // the array of primary inputs
     Vec_Ptr_t *       vPos;          // the array of primary outputs
     Vec_Ptr_t *       vCis;          // the array of combinational inputs  (PIs, latches)
     Vec_Ptr_t *       vCos;          // the array of combinational outputs (POs, asserts, latches)
     Vec_Ptr_t *       vPios;         // the array of PIOs
     Vec_Ptr_t *       vBoxes;        // the array of boxes
     Vec_Ptr_t *       vLtlProperties;
     // the number of living objects
     int nObjCounts[ABC_OBJ_NUMBER];  // the number of objects by type
     int               nObjs;         // the number of live objs
     int               nConstrs;      // the number of constraints
     int               nBarBufs;      // the number of barrier buffers
     int               nBarBufs2;     // the number of barrier buffers
     // the backup network and the step number
     Abc_Ntk_t *       pNetBackup;    // the pointer to the previous backup network
     int               iStep;         // the generation number for the given network
     // hierarchy
     Abc_Des_t *       pDesign;       // design (hierarchical networks only)
     Abc_Ntk_t *       pAltView;      // alternative structural view of the network
     int               fHieVisited;   // flag to mark the visited network
     int               fHiePath;      // flag to mark the network on the path
     int               Id;            // model ID
     double            dTemp;         // temporary value
     // miscellaneous data members
     int               nTravIds;      // the unique traversal IDs of nodes
     Vec_Int_t         vTravIds;      // trav IDs of the objects
     Mem_Fixed_t *     pMmObj;        // memory manager for objects
     Mem_Step_t *      pMmStep;       // memory manager for arrays
     void *            pManFunc;      // functionality manager (AIG manager, BDD manager, or memory manager for SOPs)
     Abc_ManTime_t *   pManTime;      // the timing manager (for mapped networks) stores arrival/required times for all nodes
     void *            pManCut;       // the cut manager (for AIGs) stores information about the cuts computed for the nodes
     float             AndGateDelay;  // an average estimated delay of one AND gate
     int               LevelMax;      // maximum number of levels
     Vec_Int_t *       vLevelsR;      // level in the reverse topological order (for AIGs)
     Vec_Ptr_t *       vSupps;        // CO support information
     int *             pModel;        // counter-example (for miters)
     Abc_Cex_t *       pSeqModel;     // counter-example (for sequential miters)
     Vec_Ptr_t *       vSeqModelVec;  // vector of counter-examples (for sequential miters)
     Abc_Ntk_t *       pExdc;         // the EXDC network (if given)
     void *            pExcare;       // the EXDC network (if given)
     void *            pData;         // misc
     Abc_Ntk_t *       pCopy;         // copy of this network
     void *            pBSMan;        // application manager
     void *            pSCLib;        // SC library
     Vec_Int_t *       vGates;        // SC library gates
     Vec_Int_t *       vPhases;       // fanins phases in the mapped netlist
     char *            pWLoadUsed;    // wire load model used
     float *           pLutTimes;     // arrivals/requireds/slacks using LUT-delay model
     Vec_Ptr_t *       vOnehots;      // names of one-hot-encoded registers
     Vec_Int_t *       vObjPerm;      // permutation saved
     Vec_Int_t *       vTopo;
     Vec_Ptr_t *       vAttrs;        // managers of various node attributes (node functionality, global BDDs, etc)
     Vec_Int_t *       vNameIds;      // name IDs
     Vec_Int_t *       vFins;         // obj/type info
 };




 3 output
 7 node
 2 input



 Abc_CommandPrintGates is where I am now






~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

found Abc_NtkShow
    - has to traverse the nodes and get the information to graph it all
    + this navigates to Abc_NtkShow() function // going there


fprintf( pFile, " %s\n", Mio_GateReadName((Mio_Gate_t *)pObj->pData) )
#include "map/mio/mio.h"




abcShow.c is where the show -g command gets executed









Abc_Print(-2, "pArray[%d] Level : %d\n",i, ((Abc_Obj_t*)pNtk->vObjs[0].pArray[i])->Level);



// testing Here!
Abc_Print(-2, "Number of Nodes: %d\n", i);
Abc_Print(-2, "nObjs: %d\n\n", pNtk->nObjs);
for (int v = i-2; v >= 0; v--){
  Abc_Print(-2, "Node Id: %d\n", (pNode-v)->Id);
  Abc_Print(-2, "Node Lvl: %d\n", (pNode-v)->Level);
  Abc_Print(-2, "Node Type: %d\n", (pNode-v)->Type);
  if(((Mio_Gate_t*)(pNode-v)->pData) != NULL){
    Abc_Print(-2, "Node Gate: %s\n", Mio_GateReadName((Mio_Gate_t*)(pNode-v)->pData));
  }
  Abc_Print(-2, "\n");
}


















1347 int Abc_NtkLevel_rec( Abc_Obj_t * pNode )
1348 {
1349     Abc_Obj_t * pNext;
1350     int i, Level;
1351     assert( !Abc_ObjIsNet(pNode) );
1352     // skip the PI
1353     if ( Abc_ObjIsCi(pNode) )
1354         return pNode->Level;
1355     assert( Abc_ObjIsNode( pNode ) || pNode->Type == ABC_OBJ_CONST1);
1356     // if this node is already visited, return
1357     if ( Abc_NodeIsTravIdCurrent( pNode ) )
1358         return pNode->Level;
1359     // mark the node as visited
1360     Abc_NodeSetTravIdCurrent( pNode );
1361     // visit the transitive fanin
1362     pNode->Level = 0;
1363     Abc_ObjForEachFanin( pNode, pNext, i )
1364     {
1365         Level = Abc_NtkLevel_rec( Abc_ObjFanin0Ntk(pNext) );
1366         if ( pNode->Level < (unsigned)Level )
1367             pNode->Level = Level;
1368     }
1369     if ( Abc_ObjFaninNum(pNode) > 0 && !Abc_ObjIsBarBuf(pNode) )
1370         pNode->Level++;
1371     return pNode->Level;
1372 }
